#include <iostream>
#include <cmath>
#include <iomanip> // для std::setprecision() - будем определять точность с плавающей точкой для вывода
/*Сравнение значений типа с плавающей точкой с помощью любого из этих операторов — дело опасное. 
Почему? Из-за тех самых небольших ошибок округления, которые могут привести к неожиданным результатам*/
#include <cmath> // для функции fabs()

/*
	-- Иногда сравнение чисел типа с плавающей точкой бывает неизбежным. 
	-- В таком случае следует использовать операторы >, <, >= и <= только если значения не очень близки.
	--Не рекомендуется использовать операторы == или != с числами типа с плавающей точкой. 
		Вместо них следует использовать функцию, которая вычисляет, насколько близки эти два значения. Если они «достаточно близки», то мы считаем их равными. 
		Значение, используемое для представления термина «достаточно близки», называется эпсилоном. Оно, обычно, небольшое (например, 0.0000001).


*/

bool isAlmostEqual(double a, double b, double epsilon); 
// a - переменная
//b - переменная
// epsilon - переменная, по которой определяем "достаточно близкое значение a к b"



int main()
{
	std::cout << std::setprecision(16);// точность в 16 цифр
	double d1(1000 - 999.99);
	std::cout << "d1 = " << d1 << std::endl;
	double d2(10 - 9.99);
	std::cout << "d2 = " << d2 << std::endl;
	if (d1 == d2)
		std::cout << "d1 == d2" << "\n";
	else if (d1 > d2)
		std::cout << "d1 > d2" << "\n";
	else if (d1 < d2)
		std::cout << "d1 < d2" << "\n";


	//проверим функцию. равно ли d1 и d2,которое выше
	std::cout<<isAlmostEqual(d1, d2, 0.0000001)<<std::endl;

	std::cin.get();
	return 0;
}

bool isAlmostEqual(double a, double b, double epsilon)
{
	// Если разница между a и b меньше значения эпсилона, то тогда a и b - "достаточно близки"

	//1 - true
	//0 - false
	return fabs(a - b) <= epsilon; // fabs() - модуль числа
}